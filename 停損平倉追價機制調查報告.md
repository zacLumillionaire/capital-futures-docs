# 停損平倉追價機制調查報告

## 📋 問題描述

根據平倉紀錄.md的分析，發現兩口部位（36和37）進入停損平倉後，雖然下單成功但沒有成功繼續追價。按照空單平倉邏輯，如果平倉失敗應該要用新報價的ASK1進行重新送出平倉，但系統沒有正常執行追價機制。

### 關鍵現象
- ✅ 停損觸發正常：部位36和37都正確觸發停損
- ✅ 平倉下單成功：兩個部位都成功下單（訂單ID: 2b34205f, 8c64721f）
- ❌ 追價機制失效：只有部位36執行了一次追價，部位37完全沒有追價
- ❌ 回報處理異常：LOG顯示「所有追蹤器都未處理此回報」

## 🔍 技術分析

### Task 1: 停損平倉運作機制分析

#### 核心模組交互流程
```
OptimizedRiskManager → StopExecutor → SimplifiedTracker
     ↓                      ↓               ↓
  觸發檢測              執行平倉         追價回調
```

**關鍵發現**：
1. **OptimizedRiskManager**: 正常檢測到停損觸發條件
2. **StopExecutor**: 成功執行平倉下單並註冊到SimplifiedTracker
3. **SimplifiedTracker**: 追價回調機制存在問題

### Task 2: LOG分析與代碼比對

#### 關鍵LOG分析
```
第147行: ⚠️ [REPLY] 所有追蹤器都未處理此回報
第149行: [FIFO_MATCHER] ⚠️ 純FIFO找不到匹配: TM0000 1口 @23304.0
第179行: [SIMPLIFIED_TRACKER] 🔄 平倉組36第1口觸發追價: 第1次, 1口
```

**問題識別**：
1. **回報處理鏈斷裂**：SimplifiedTracker無法處理取消回報
2. **FIFO匹配失敗**：商品代碼匹配邏輯有問題
3. **部分追價執行**：只有部位36觸發追價，部位37被忽略

### Task 3: 停損vs移動停利追價機制比較

#### 追價機制對比
| 項目 | 停損平倉 | 移動停利平倉 | 一致性 |
|------|----------|--------------|--------|
| 執行器 | StopExecutor | StopExecutor | ✅ 相同 |
| 註冊方式 | register_exit_group | register_exit_group | ✅ 相同 |
| 追價回調 | SimplifiedTracker | SimplifiedTracker | ✅ 相同 |
| 商品代碼 | "TM0000" | "TM0000" | ✅ 相同 |
| 價格計算 | ASK1+retry_count | ASK1+retry_count | ✅ 相同 |

**結論**：兩種平倉機制使用完全相同的追價邏輯，問題不在機制設計差異。

## 🎯 根因分析

### 核心問題：商品代碼匹配失效

#### 問題1: 註冊vs回報的商品代碼不匹配
```python
# StopExecutor註冊時使用
product="TM0000"

# 回報處理時收到
product="TM2508"  # 實際合約代碼

# SimplifiedTracker標準化邏輯
def _normalize_product_code(self, product: str) -> str:
    if product.startswith("TM") and len(product) == 6:
        return "TM0000"  # TM2508 → TM0000
```

**分析**：雖然有標準化邏輯，但在某些情況下匹配仍然失敗。

#### 問題2: FIFO匹配時間窗口問題
```python
# 時間窗口檢查（30秒內）
if current_time - exit_info['submit_time'] > 30:
    continue
```

**分析**：如果系統處理延遲，可能導致訂單超出時間窗口。

#### 問題3: 回報處理優先級問題
```python
# 回報處理順序
1. SimplifiedTracker.process_order_reply()
2. TotalLotTracker (如果SimplifiedTracker失敗)
3. UnifiedOrderTracker (如果前兩者都失敗)
```

**分析**：當SimplifiedTracker處理失敗時，其他追蹤器無法觸發平倉追價。

## 💡 解決方案建議

### 方案1: 增強商品代碼匹配邏輯
```python
def _normalize_product_code(self, product: str) -> str:
    """增強版商品代碼標準化"""
    # 記錄原始代碼用於調試
    if self.console_enabled:
        print(f"[SIMPLIFIED_TRACKER] 🔍 標準化商品代碼: {product}")
    
    if product.startswith("TM") and len(product) >= 4:
        normalized = "TM0000"
        if self.console_enabled:
            print(f"[SIMPLIFIED_TRACKER] 📝 {product} → {normalized}")
        return normalized
    
    return product
```

### 方案2: 改善FIFO匹配容錯性
```python
def _find_matching_exit_order(self, price: float, qty: int, product: str, for_cancel=False):
    """增強版FIFO匹配"""
    # 1. 放寬時間窗口（60秒）
    time_window = 60
    
    # 2. 增加調試信息
    if self.console_enabled:
        print(f"[SIMPLIFIED_TRACKER] 🔍 搜尋平倉訂單:")
        print(f"  條件: 商品={product}, 價格={price}, 數量={qty}")
        print(f"  現有訂單數量: {len(self.exit_orders)}")
    
    # 3. 如果精確匹配失敗，嘗試模糊匹配
    if not candidates and for_cancel:
        # 取消回報特殊處理：只匹配商品和時間
        for order_id, exit_info in self.exit_orders.items():
            if (self._normalize_product_code(exit_info['product']) == normalized_product and
                current_time - exit_info['submit_time'] <= time_window):
                candidates.append((exit_info['submit_time'], order_id, exit_info))
```

### 方案3: 增加回報處理備援機制
```python
def process_order_reply(self, reply_data: str) -> bool:
    """增強版回報處理"""
    try:
        # 原有處理邏輯
        processed = self._handle_original_logic(reply_data)
        
        # 如果處理失敗，嘗試備援邏輯
        if not processed and order_type == "C":  # 取消回報
            processed = self._handle_cancel_fallback(reply_data)
            
        return processed
    except Exception as e:
        if self.console_enabled:
            print(f"[SIMPLIFIED_TRACKER] ❌ 回報處理異常: {e}")
            print(f"[SIMPLIFIED_TRACKER] 📋 回報內容: {reply_data}")
        return False
```

### 方案4: 增強調試和監控
```python
def _trigger_exit_retry_callbacks(self, exit_order):
    """增強版追價回調觸發"""
    if self.console_enabled:
        print(f"[SIMPLIFIED_TRACKER] 🔄 觸發平倉追價回調:")
        print(f"  部位ID: {exit_order['position_id']}")
        print(f"  註冊的回調數量: {len(self.exit_retry_callbacks)}")
        print(f"  回調函數列表: {[str(cb) for cb in self.exit_retry_callbacks]}")
    
    for i, callback in enumerate(self.exit_retry_callbacks):
        try:
            if self.console_enabled:
                print(f"[SIMPLIFIED_TRACKER] 📞 執行回調{i+1}...")
            callback(exit_order)
            if self.console_enabled:
                print(f"[SIMPLIFIED_TRACKER] ✅ 回調{i+1}執行成功")
        except Exception as e:
            if self.console_enabled:
                print(f"[SIMPLIFIED_TRACKER] ❌ 回調{i+1}執行失敗: {e}")
```

## 🚀 實施建議

### 優先級1: 立即修復（高風險）
1. **增強商品代碼匹配邏輯**：確保TM2508能正確匹配到TM0000
2. **增加調試日誌**：在關鍵節點增加詳細日誌輸出

### 優先級2: 短期改善（中風險）
1. **改善FIFO匹配容錯性**：放寬時間窗口和匹配條件
2. **增加回報處理備援機制**：確保取消回報能被正確處理

### 優先級3: 長期優化（低風險）
1. **重構回報處理架構**：統一回報處理邏輯
2. **增強監控和告警**：實時監控追價機制運行狀態

## 📊 預期效果

實施上述修復方案後，預期能夠：
- ✅ 解決商品代碼匹配問題，確保100%的停損平倉能被正確識別
- ✅ 提高FIFO匹配成功率，減少「找不到匹配訂單」的情況
- ✅ 確保所有停損平倉都能正常觸發追價機制
- ✅ 提供詳細的調試信息，便於後續問題排查

---

**報告撰寫時間**: 2025-07-18  
**調查範圍**: Capital_Official_Framework 停損平倉追價機制  
**問題嚴重程度**: 高（影響交易系統核心功能）  
**建議處理時間**: 24小時內完成優先級1修復
