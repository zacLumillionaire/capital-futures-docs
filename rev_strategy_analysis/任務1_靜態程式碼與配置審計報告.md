# 任務 1：靜態程式碼與配置審計報告

## 執行日期
2025-01-16

## 審計目標
比較 `mdd_gui.py` 和 `rev_web_trading_gui.py` 的導入模組、配置文件讀取、交易成本參數和核心計算邏輯，找出所有潛在差異。

## 1. 導入模組比較

### mdd_gui.py 導入模組
```python
from flask import Flask, render_template_string, request, jsonify, send_file
import subprocess
import json
import os
import threading
import logging
from datetime import datetime
from pathlib import Path
```

### rev_web_trading_gui.py 導入模組
```python
from flask import Flask, render_template_string, request, jsonify, redirect, url_for, send_file
import subprocess
import sys
import os
import json
import threading
import glob
import shutil
from datetime import datetime
from pathlib import Path

# 🚀 【Task 2 新增】直接導入核心回測引擎
import importlib.util
spec = importlib.util.spec_from_file_location(
    "rev_multi_module",
    "rev_multi_Profit-Funded Risk_多口.py"
)
rev_multi_module = importlib.util.module_from_spec(spec)
spec.loader.exec_module(rev_multi_module)

# 導入所需的函數
core_run_backtest = rev_multi_module.run_backtest

# 🚀 【重構】導入統一的配置工廠
from strategy_config_factory import create_config_from_gui_dict
```

### 差異分析
1. **核心差異**：`rev_web_trading_gui.py` 直接導入核心回測引擎，而 `mdd_gui.py` 使用 subprocess 調用
2. **額外模組**：`rev_web_trading_gui.py` 導入了 `redirect`, `url_for`, `sys`, `glob`, `shutil`, `importlib.util`
3. **配置工廠**：`rev_web_trading_gui.py` 使用統一的配置工廠 `strategy_config_factory`

## 2. 核心回測引擎比較

### mdd_gui.py 調用的回測引擎
- **引擎文件**：`enhanced_mdd_optimizer.py` → `exp_rev_multi_Profit-Funded Risk_多口.py`
- **調用方式**：subprocess 調用
- **命令**：`python enhanced_mdd_optimizer.py --config time_interval_analysis --max-workers 6`

### rev_web_trading_gui.py 調用的回測引擎
- **引擎文件**：`rev_multi_Profit-Funded Risk_多口.py`
- **調用方式**：直接函數調用
- **函數**：`core_run_backtest(strategy_config, start_date, end_date, range_start_time, range_end_time)`

## 3. PNL 和 MDD 計算邏輯差異

### mdd_gui.py (enhanced_mdd_optimizer.py)
```python
def _calculate_mdd_from_logs(self, stderr_output):
    """從交易日誌計算 MDD"""
    current_pnl = 0
    peak_pnl = 0
    max_dd = 0

    for line in lines:
        if '損益:' in line:
            # 解析損益行：格式 "損益: +23" 或 "損益: -15"
            pnl_str = parts[1].strip().split()[0]
            trade_pnl = float(pnl_str)
            current_pnl += trade_pnl
            
            # 更新峰值
            if current_pnl > peak_pnl:
                peak_pnl = current_pnl
            
            # 計算回撤
            drawdown = peak_pnl - current_pnl
            if drawdown > max_dd:
                max_dd = drawdown

    return -max_dd if max_dd > 0 else 0
```

### rev_web_trading_gui.py (rev_multi_Profit-Funded Risk_多口.py)
```python
# 在 run_backtest 函數中
cumulative_pnl = Decimal(0)
peak_pnl = Decimal(0)
max_drawdown = Decimal(0)

for day in trade_days:
    day_pnl, trade_direction, lot_pnls = _run_multi_lot_logic(...)
    
    total_pnl += day_pnl
    cumulative_pnl += day_pnl
    
    # 計算 MDD
    if cumulative_pnl > peak_pnl:
        peak_pnl = cumulative_pnl
    
    current_drawdown = peak_pnl - cumulative_pnl
    if current_drawdown > max_drawdown:
        max_drawdown = current_drawdown

return {
    'max_drawdown': float(max_drawdown),
    'peak_pnl': float(peak_pnl),
    ...
}
```

### 關鍵差異
1. **數據類型**：`mdd_gui.py` 使用 `float`，`rev_web_trading_gui.py` 使用 `Decimal`
2. **計算時機**：`mdd_gui.py` 從日誌解析每筆交易，`rev_web_trading_gui.py` 按交易日計算
3. **數據來源**：`mdd_gui.py` 解析文本日誌，`rev_web_trading_gui.py` 直接使用結構化數據

## 4. 數據讀取方式差異

### mdd_gui.py
- 通過 subprocess 調用，解析 stderr 輸出
- 使用正則表達式和字符串解析提取數據
- 依賴日誌格式的一致性

### rev_web_trading_gui.py
- 直接函數調用，返回結構化字典
- 無需解析，直接使用返回的數據結構
- 數據類型和格式保證一致

## 5. 交易成本參數設定

### 共同點
- 兩個系統都沒有在 GUI 層面明確設定手續費和滑價參數
- 交易成本設定應該在核心回測引擎中處理

### 需要進一步檢查
- 核心回測引擎中的交易成本設定是否一致
- 是否有隱含的交易成本差異

## 6. 配置文件讀取差異

### mdd_gui.py
- 創建臨時配置文件 `temp_gui_config.json`
- 修改 `mdd_search_config.py` 文件
- 使用配置文件驅動的方式

### rev_web_trading_gui.py
- 使用 `strategy_config_factory.create_config_from_gui_dict()`
- 直接創建配置對象
- 無需臨時文件

## 7. 核心計算邏輯差異總結

### 主要差異點
1. **執行方式**：subprocess vs 直接函數調用
2. **數據精度**：float vs Decimal
3. **MDD 計算粒度**：逐筆交易 vs 逐日累積
4. **數據傳遞**：文本解析 vs 結構化數據
5. **錯誤處理**：依賴日誌解析 vs 直接異常處理

### 潛在不一致原因
1. **精度損失**：float 和 Decimal 的精度差異
2. **解析錯誤**：文本解析可能遺漏或錯誤解析某些數據
3. **計算時機**：不同的累積方式可能導致 MDD 計算差異
4. **數據完整性**：subprocess 可能遺漏部分輸出

## 8. 建議後續檢查項目

1. **任務 2**：驗證兩個系統使用的底層數據源是否完全一致
2. **任務 3**：通過詳細日誌追蹤找到第一個產生差異的計算點
3. **任務 4**：隔離核心計算函數進行單元測試
4. **檢查交易成本設定**：確認兩個核心引擎的手續費和滑價設定

## 結論

靜態分析顯示兩個系統在架構和計算方式上存在根本性差異，這很可能是導致 PNL 和 MDD 計算不一致的主要原因。最關鍵的差異是數據精度（float vs Decimal）和計算方式（文本解析 vs 直接計算）。
