# 任務1：靜態程式碼與配置審計報告

**執行日期：** 2025-07-17  
**審計目標：** 比較 mdd_gui.py 和 rev_web_trading_gui.py 的所有潛在差異點

## 🔍 1. 導入模組比較

### mdd_gui.py 導入模組
```python
from flask import Flask, render_template_string, request, jsonify, send_file
import subprocess
import json
import os
import threading
import logging
from datetime import datetime
from pathlib import Path
```

### rev_web_trading_gui.py 導入模組
```python
from flask import Flask, render_template_string, request, jsonify, redirect, url_for, send_file
import subprocess
import sys
import os
import json
import threading
import glob
import shutil
from datetime import datetime
from pathlib import Path
import importlib.util
import inspect
from strategy_config_factory import create_config_from_gui_dict
```

### 🚨 關鍵差異分析
1. **額外模組**：`rev_web_trading_gui.py` 導入了 `redirect`, `url_for`, `sys`, `glob`, `shutil`, `importlib.util`, `inspect`
2. **配置工廠**：`rev_web_trading_gui.py` 使用統一的配置工廠 `strategy_config_factory`
3. **核心引擎導入**：`rev_web_trading_gui.py` 直接導入核心回測引擎，而 `mdd_gui.py` 不導入

## 🔍 2. 核心回測引擎調用方式

### mdd_gui.py 調用方式
- **調用方式**：subprocess 調用
- **目標程式**：`enhanced_mdd_optimizer.py`
- **命令**：`python enhanced_mdd_optimizer.py --config time_interval_analysis --max-workers 6`
- **數據流**：GUI → subprocess → enhanced_mdd_optimizer.py → exp_rev_multi_Profit-Funded Risk_多口.py

### rev_web_trading_gui.py 調用方式
- **調用方式**：直接函數調用
- **目標程式**：`rev_multi_Profit-Funded Risk_多口.py`
- **函數**：`core_run_backtest(strategy_config, start_date, end_date, range_start_time, range_end_time)`
- **數據流**：GUI → 直接函數調用 → rev_multi_Profit-Funded Risk_多口.py

### 🚨 關鍵差異分析
1. **調用層級**：mdd_gui.py 有額外的中間層 (enhanced_mdd_optimizer.py)
2. **數據傳遞**：mdd_gui.py 通過 subprocess 和日誌解析，rev_web_trading_gui.py 直接返回結構化數據
3. **錯誤處理**：不同的錯誤處理機制

## 🔍 3. 配置文件讀取與處理

### mdd_gui.py 配置處理
```python
def create_temp_config(params):
    """創建臨時配置檔案"""
    config_data = {
        "time_intervals": params.get('time_intervals', []),
        "lot1_stop_loss": params.get('lot1_stop_loss', [15]),
        "lot2_stop_loss": params.get('lot2_stop_loss', [40]),
        "lot3_stop_loss": params.get('lot3_stop_loss', [41]),
        "lot1_take_profit": params.get('lot1_take_profit', [60]),
        "lot2_take_profit": params.get('lot2_take_profit', [80]),
        "lot3_take_profit": params.get('lot3_take_profit', [100]),
        "max_workers": params.get('max_workers', 6)
    }
    return config_data
```

### rev_web_trading_gui.py 配置處理
```python
def execute_backtest_thread(config_data):
    gui_config = {
        "trade_lots": config_data.get("trade_lots", 3),
        "start_date": config_data.get("start_date", "2024-11-01"),
        "end_date": config_data.get("end_date", "2024-11-30"),
        "range_start_time": config_data.get("range_start_time", "08:46"),
        "range_end_time": config_data.get("range_end_time", "08:47"),
        "fixed_stop_mode": config_data.get("fixed_stop_mode", True),
        "individual_take_profit_enabled": config_data.get("individual_take_profit_enabled", False),
        "entry_price_mode": config_data.get("entry_price_mode", "range_boundary"),
        "trading_direction": config_data.get("trading_direction", "BOTH"),
        "lot_settings": { ... },
        "filters": { ... }
    }
    strategy_config = create_config_from_gui_dict(gui_config)
```

### 🚨 關鍵差異分析
1. **配置結構**：完全不同的配置數據結構
2. **配置工廠**：rev_web_trading_gui.py 使用統一配置工廠，mdd_gui.py 直接創建配置
3. **參數映射**：不同的參數名稱和預設值

## 🔍 4. 交易成本參數審計

### 搜尋結果
- **手續費關鍵字**：在兩個文件中都未找到明確的手續費設定
- **滑價關鍵字**：在兩個文件中都未找到明確的滑價設定
- **交易成本**：兩個文件都依賴底層回測引擎的預設交易成本設定

### 🚨 關鍵發現
兩個GUI都沒有明確設定交易成本參數，這意味著它們依賴各自調用的回測引擎的內建設定。

## 🔍 5. PNL和MDD計算邏輯差異

### mdd_gui.py (通過 enhanced_mdd_optimizer.py)
```python
def _calculate_mdd_from_logs(self, stderr_output):
    """從交易日誌計算 MDD"""
    current_pnl = 0
    peak_pnl = 0
    max_dd = 0

    for line in lines:
        if '損益:' in line:
            pnl_str = parts[1].strip().split()[0]
            trade_pnl = float(pnl_str)
            current_pnl += trade_pnl
            
            if current_pnl > peak_pnl:
                peak_pnl = current_pnl
            
            drawdown = peak_pnl - current_pnl
            if drawdown > max_dd:
                max_dd = drawdown

    return -max_dd if max_dd > 0 else 0
```

### rev_web_trading_gui.py (直接從回測引擎)
```python
# 直接從 rev_multi_Profit-Funded Risk_多口.py 獲取結構化結果
backtest_results_dict = core_run_backtest(...)
# 結果包含：
{
    'total_pnl': float(total_pnl),
    'long_pnl': float(long_pnl),
    'short_pnl': float(short_pnl),
    'max_drawdown': float(max_drawdown),
    'peak_pnl': float(peak_pnl),
    ...
}
```

### 🚨 關鍵差異分析
1. **計算方式**：mdd_gui.py 通過日誌解析計算，rev_web_trading_gui.py 直接獲取計算結果
2. **數據精度**：日誌解析可能存在精度損失
3. **計算時機**：不同的計算時機可能導致結果差異

## 📋 總結

### 主要差異點
1. **架構差異**：mdd_gui.py 使用 subprocess + 日誌解析，rev_web_trading_gui.py 使用直接函數調用
2. **配置差異**：完全不同的配置結構和參數映射
3. **計算差異**：不同的 PNL/MDD 計算和獲取方式
4. **數據流差異**：不同的數據傳遞路徑

### 潛在問題根源
1. **中間層影響**：enhanced_mdd_optimizer.py 可能引入額外的計算邏輯
2. **日誌解析精度**：字符串解析可能導致數值精度問題
3. **配置不一致**：不同的配置可能導致不同的回測行為
4. **回測引擎版本**：可能調用不同版本的回測引擎

### 建議後續調查方向
1. 比較兩個回測引擎文件的具體差異
2. 驗證配置工廠的參數轉換邏輯
3. 檢查日誌解析的精度問題
4. 確認交易成本設定的一致性
