# 建倉資料庫錯誤診斷報告

## 📋 問題摘要

**錯誤信息**: `'>=' not supported between instances of 'NoneType' and 'int'`  
**發生位置**: `multi_group_database.py` 資料庫 CHECK 約束  
**影響範圍**: 建倉成功但部位狀態更新失敗，導致風險管理無法正常運作  

---

## 🔍 根本原因分析

### 1. 錯誤觸發點

**位置**: `Capital_Official_Framework/multi_group_database.py` 第88行
```sql
CHECK(retry_count >= 0 AND retry_count <= 5)
```

**問題**: 當 `retry_count` 字段為 `None` 時，SQLite 嘗試執行 `None >= 0` 比較，導致 Python 類型錯誤。

### 2. 數據流分析

#### 2.1 建倉流程
```
1. 創建策略組 ✅ (成功)
2. 創建部位記錄 ✅ (成功，但 retry_count=None)
3. 下單成功 ✅ (API 返回正常)
4. 成交回報處理 ✅ (FIFO 匹配成功)
5. 部位狀態更新 ❌ (CHECK 約束失敗)
```

#### 2.2 問題字段
從日誌分析，以下字段可能為 `None`：
- `retry_count`: 重試次數 (應為 0)
- `max_slippage_points`: 最大滑價點數 (應為 > 0)

### 3. 具體錯誤位置

#### 3.1 創建部位記錄
**文件**: `multi_group_database.py` 第368-374行
```python
cursor.execute('''
    INSERT INTO position_records
    (group_id, lot_id, direction, entry_price, entry_time, rule_config,
     order_id, api_seq_no, order_status)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
''', (group_id, lot_id, direction, entry_price, entry_time, rule_config,
      order_id, api_seq_no, order_status))
```

**問題**: 缺少 `retry_count` 和 `max_slippage_points` 字段的明確設置

#### 3.2 CHECK 約束
**文件**: `multi_group_database.py` 第88-89行
```sql
CHECK(retry_count >= 0 AND retry_count <= 5),
CHECK(max_slippage_points > 0)
```

**問題**: 約束不允許 `None` 值，但創建時未提供預設值

---

## 🛠️ 修復方案

### 方案 1: 修改 CHECK 約束 (推薦)

**優點**: 
- 允許 `None` 值，向後兼容
- 不影響現有數據
- 修復簡單

**實施**:
```sql
-- 修改前
CHECK(retry_count >= 0 AND retry_count <= 5)
CHECK(max_slippage_points > 0)

-- 修改後
CHECK(retry_count IS NULL OR (retry_count >= 0 AND retry_count <= 5))
CHECK(max_slippage_points IS NULL OR max_slippage_points > 0)
```

### 方案 2: 設置預設值

**優點**: 
- 數據完整性更好
- 邏輯更清晰

**實施**:
```python
# 在 create_position_record 方法中添加預設值
def create_position_record(self, group_id: int, lot_id: int, direction: str,
                         entry_price: Optional[float] = None, 
                         entry_time: Optional[str] = None,
                         rule_config: Optional[str] = None, 
                         order_id: Optional[str] = None,
                         api_seq_no: Optional[str] = None, 
                         order_status: str = 'PENDING',
                         retry_count: int = 0,  # 新增預設值
                         max_slippage_points: float = 5.0) -> int:  # 新增預設值
```

---

## 🔧 立即修復步驟

### 步驟 1: 修改 CHECK 約束 (最安全)

1. **備份資料庫**
2. **修改約束**
3. **測試驗證**

### 步驟 2: 更新創建邏輯

1. **添加預設值參數**
2. **更新 INSERT 語句**
3. **測試建倉流程**

---

## 📊 影響評估

### 當前狀況
- ✅ **建倉成功**: 訂單正常下單和成交
- ❌ **狀態更新失敗**: 部位保持 PENDING 狀態
- ❌ **風險管理受影響**: 進場價格為 None，無法計算停損

### 修復後預期
- ✅ **完整建倉流程**: 從下單到狀態更新全部正常
- ✅ **風險管理正常**: 進場價格正確記錄，停損計算正常
- ✅ **數據完整性**: 所有字段都有有效值

---

## 🧪 檢測方法

### 檢測腳本
```python
# 檢查部位記錄的字段完整性
def check_position_data_integrity():
    with sqlite3.connect('multi_group_strategy.db') as conn:
        cursor = conn.cursor()
        
        # 檢查 None 值
        cursor.execute('''
            SELECT id, retry_count, max_slippage_points, entry_price
            FROM position_records 
            WHERE status = 'ACTIVE'
        ''')
        
        for row in cursor.fetchall():
            pos_id, retry_count, max_slippage, entry_price = row
            if retry_count is None:
                print(f"⚠️ 部位 {pos_id}: retry_count 為 None")
            if max_slippage is None:
                print(f"⚠️ 部位 {pos_id}: max_slippage_points 為 None")
            if entry_price is None:
                print(f"⚠️ 部位 {pos_id}: entry_price 為 None")
```

### 驗證建倉流程
```python
# 測試完整建倉流程
def test_position_creation():
    # 1. 創建測試策略組
    # 2. 創建部位記錄
    # 3. 模擬成交更新
    # 4. 檢查數據完整性
    pass
```

---

## 🎯 優先級建議

### 🔴 高優先級 (立即修復)
1. **修改 CHECK 約束** - 解決當前錯誤
2. **添加預設值** - 確保數據完整性

### 🟡 中優先級 (後續優化)
1. **完善錯誤處理** - 更好的異常捕獲
2. **添加數據驗證** - 創建前檢查字段完整性

### 🟢 低優先級 (長期改進)
1. **重構資料庫設計** - 更合理的約束設計
2. **添加單元測試** - 防止類似問題再次發生

---

## 📝 總結

這是一個典型的**資料庫約束與應用邏輯不匹配**問題。建倉功能本身正常，但資料庫更新時觸發了嚴格的 CHECK 約束。通過修改約束或添加預設值，可以快速解決問題並恢復系統正常運行。
