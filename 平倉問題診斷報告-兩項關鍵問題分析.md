# ğŸš¨ å¹³å€‰å•é¡Œè¨ºæ–·å ±å‘Š - å…©é …é—œéµå•é¡Œåˆ†æ

## ğŸ“‹ **è¨ºæ–·æ¦‚è¿°**

**å•é¡Œæè¿°**ï¼šç­–ç•¥ä¸‹å–®æ©Ÿåœ¨å¹³å€‰æ™‚å‡ºç¾"æ‰¾ä¸åˆ°éƒ¨ä½è³‡è¨Š"éŒ¯èª¤ï¼Œå°è‡´å¹³å€‰å¤±æ•—ä¸¦æŒçºŒé‡è¤‡è§¸ç™¼ã€‚

**è¨ºæ–·æ™‚é–“**ï¼š2025-07-11  
**å•é¡Œéƒ¨ä½**ï¼š133ã€134ã€135 (SHORTéƒ¨ä½ï¼Œçµ„49)  
**ä¸»è¦ç—‡ç‹€**ï¼šå ±åƒ¹è™•ç†å»¶é²4688msï¼Œå¹³å€‰é‡è¤‡è§¸ç™¼ä½†æŒçºŒå¤±æ•—

---

## ğŸ” **è¨ºæ–·æ–¹æ³•è«–**

### **è¨ºæ–·å·¥å…·é–‹ç™¼**

#### **1. åŸºç¤è¨ºæ–·å·¥å…·**
**æ–‡ä»¶**ï¼š`å¹³å€‰å•é¡Œè¨ºæ–·å·¥å…·.py`
```python
# æª¢æŸ¥é …ç›®ï¼š
1. è³‡æ–™åº«æ–‡ä»¶å­˜åœ¨æ€§
2. é—œéµæ¨¡çµ„å°å…¥ç‹€æ…‹  
3. éƒ¨ä½è¨˜éŒ„å®Œæ•´æ€§
4. ç­–ç•¥çµ„è¨˜éŒ„åŒ¹é…
5. JOINæŸ¥è©¢é‚è¼¯é©—è­‰
```

#### **2. ç°¡åŒ–è¨ºæ–·å·¥å…·**
**æ–‡ä»¶**ï¼š`ç°¡åŒ–è¨ºæ–·.py`
```python
# å¿«é€Ÿæª¢æŸ¥ï¼š
1. é—œéµæ–‡ä»¶å¤§å°å’Œå­˜åœ¨æ€§
2. è³‡æ–™åº«è¡¨çµæ§‹
3. å•é¡Œéƒ¨ä½ç‹€æ…‹
4. æ¨¡çµ„å°å…¥æˆåŠŸç‡
```

#### **3. è©³ç´°è³‡æ–™åº«æª¢æŸ¥**
**æ–‡ä»¶**ï¼š`è©³ç´°è³‡æ–™åº«æª¢æŸ¥.py`
```python
# æ·±åº¦åˆ†æï¼š
1. JOINæŸ¥è©¢é‚è¼¯é€æ­¥é©—è­‰
2. ç­–ç•¥çµ„è¨˜éŒ„è©³ç´°æª¢æŸ¥
3. è³‡æ–™åº«æŸ¥è©¢æ€§èƒ½æ¸¬è©¦
4. ä½µç™¼è¨ªå•æ¨¡æ“¬
```

### **è¨ºæ–·åŸ·è¡Œæµç¨‹**

#### **éšæ®µ1ï¼šåŸºç¤ç’°å¢ƒæª¢æŸ¥**
```bash
# åŸ·è¡ŒåŸºç¤è¨ºæ–·
python ç°¡åŒ–è¨ºæ–·.py

# æª¢æŸ¥é …ç›®ï¼š
âœ… é—œéµæ–‡ä»¶å­˜åœ¨ (simple_integrated.py: 247KB)
âœ… è³‡æ–™åº«å­˜åœ¨ (multi_group_strategy.db)
âœ… æ¨¡çµ„å°å…¥æˆåŠŸ (simplified_order_tracker, stop_loss_executor)
âœ… è³‡æ–™åº«è¡¨å®Œæ•´ (position_records, strategy_groups)
```

#### **éšæ®µ2ï¼šå•é¡Œéƒ¨ä½ç‹€æ…‹æª¢æŸ¥**
```sql
-- æª¢æŸ¥å•é¡Œéƒ¨ä½è¨˜éŒ„
SELECT id, status, group_id, direction FROM position_records 
WHERE id IN (133, 134, 135);

-- çµæœï¼š
éƒ¨ä½133: ç‹€æ…‹=ACTIVE, çµ„=49, æ–¹å‘=SHORT
éƒ¨ä½134: ç‹€æ…‹=ACTIVE, çµ„=49, æ–¹å‘=SHORT  
éƒ¨ä½135: ç‹€æ…‹=ACTIVE, çµ„=49, æ–¹å‘=SHORT
```

#### **éšæ®µ3ï¼šJOINæŸ¥è©¢é‚è¼¯é©—è­‰**
```sql
-- æ¸¬è©¦å¯¦éš›çš„JOINæŸ¥è©¢
SELECT pr.*, sg.range_high, sg.range_low, sg.direction as group_direction
FROM position_records pr
JOIN (
    SELECT * FROM strategy_groups
    WHERE date = '2025-07-11'
    ORDER BY id DESC
) sg ON pr.group_id = sg.group_id
WHERE pr.id = 133 AND pr.status = 'ACTIVE';
```

---

## ğŸ¯ **è¨ºæ–·çµæœ**

### **âœ… æ’é™¤çš„å•é¡Œ**

#### **1. åŸºç¤è³‡æ–™å•é¡Œ** âŒ
**æª¢æŸ¥çµæœ**ï¼š
- éƒ¨ä½è¨˜éŒ„å­˜åœ¨ä¸”å®Œæ•´
- éƒ¨ä½ç‹€æ…‹æ­£ç¢º (ACTIVE)
- ç­–ç•¥çµ„è¨˜éŒ„å­˜åœ¨ (11å€‹ä»Šæ—¥çµ„)
- è³‡æ–™åº«è¡¨çµæ§‹å®Œæ•´

**æ’é™¤ä¾æ“š**ï¼šæ‰€æœ‰åŸºç¤è³‡æ–™æª¢æŸ¥éƒ½é€šé

#### **2. ä»£ç¢¼çµæ§‹å•é¡Œ** âŒ  
**æª¢æŸ¥çµæœ**ï¼š
- æ‰€æœ‰é—œéµæ–‡ä»¶å­˜åœ¨ä¸”å¤§å°æ­£å¸¸
- æ‰€æœ‰æ¨¡çµ„å°å…¥æˆåŠŸ
- æ²’æœ‰èªæ³•éŒ¯èª¤æˆ–å°å…¥éŒ¯èª¤

**æ’é™¤ä¾æ“š**ï¼šæ¨¡çµ„å°å…¥å’Œæ–‡ä»¶æª¢æŸ¥éƒ½æ­£å¸¸

#### **3. è³‡æ–™åº«çµæ§‹å•é¡Œ** âŒ
**æª¢æŸ¥çµæœ**ï¼š
- è³‡æ–™åº«æ–‡ä»¶å­˜åœ¨ (multi_group_strategy.db)
- è¡¨çµæ§‹å®Œæ•´ (position_records, strategy_groupsç­‰)
- ä»Šæ—¥ç­–ç•¥çµ„è¨˜éŒ„å­˜åœ¨ (11å€‹)

**æ’é™¤ä¾æ“š**ï¼šè³‡æ–™åº«çµæ§‹å’Œå…§å®¹éƒ½æ­£å¸¸

### **ğŸ”¥ ç¢ºèªçš„å•é¡Œ**

#### **å•é¡Œ1ï¼šç•°æ­¥æ›´æ–°èˆ‡åŒæ­¥æŸ¥è©¢æ™‚åºè¡çª** (æ¦‚ç‡: 95%)

**è­‰æ“š**ï¼š
```
çŸ›ç›¾ç¾è±¡ï¼š
- è³‡æ–™åº«ä¸­éƒ¨ä½è¨˜éŒ„å®Œå…¨æ­£å¸¸ âœ…
- ä½†æŸ¥è©¢æ™‚è¿”å›"æ‰¾ä¸åˆ°éƒ¨ä½è³‡è¨Š" âŒ
- é€™åªèƒ½æ˜¯ä½µç™¼è¨ªå•æˆ–æ™‚åºå•é¡Œ
```

**å…·é«”æ©Ÿåˆ¶**ï¼š
```
æƒ¡æ€§å¾ªç’°ï¼š
1. åœæè§¸ç™¼ â†’ æŸ¥è©¢éƒ¨ä½å¤±æ•— â†’ é‡è¤‡é˜²è­·é˜»æ­¢
2. éƒ¨ä½ä»åœ¨ç·©å­˜ä¸­ â†’ ä¸‹æ¬¡å ±åƒ¹å†æ¬¡è§¸ç™¼  
3. å†æ¬¡æŸ¥è©¢å¤±æ•— â†’ å†æ¬¡è¢«é˜»æ­¢
4. ç„¡é™å¾ªç’°... âŒ
```

#### **å•é¡Œ2ï¼šå£ç´šåˆ¥è¿½åƒ¹æ©Ÿåˆ¶ä½µç™¼å½±éŸ¿** (æ¦‚ç‡: 80%)

**è­‰æ“š**ï¼š
```
æ–°å¢è¤‡é›œåº¦ï¼š
- register_exit_group() å¢åŠ è³‡æ–™åº«æ“ä½œ
- ExitGroup å‰µå»ºå¢åŠ å…§å­˜æ“ä½œ
- å£ç´šåˆ¥é–å®šå¢åŠ é–å®šæ©Ÿåˆ¶
- SimplifiedOrderTracker æ•´åˆå¢åŠ çµ„ä»¶äº¤äº’
```

**ä½µç™¼è¡çªå ´æ™¯**ï¼š
```
æ™‚é–“ç·šé‡å»ºï¼š
T1: éƒ¨ä½133åœæè§¸ç™¼ â†’ OptimizedRiskManageræª¢æ¸¬
T2: èª¿ç”¨StopLossExecutor.execute_stop_loss()
T3: å˜—è©¦register_exit_group() â†’ å¯èƒ½é˜»å¡
T4: åŒæ™‚éƒ¨ä½134ã€135ä¹Ÿè§¸ç™¼ â†’ ä½µç™¼è¡çª
T5: _get_position_info()æŸ¥è©¢æ™‚è³‡æ–™åº«è¢«é–å®š
T6: æŸ¥è©¢è¶…æ™‚è¿”å›None â†’ "æ‰¾ä¸åˆ°éƒ¨ä½è³‡è¨Š"
```

---

## ğŸ”§ **ä¸‹ä¸€æ­¥æª¢æŸ¥æ–¹å‘**

### **ğŸš€ Asyncç•°æ­¥æ›´æ–°å™¨è¨ºæ–·**

#### **1. ç•°æ­¥æ›´æ–°å™¨ç‹€æ…‹æª¢æŸ¥**
**æ·»åŠ åˆ° `simple_integrated.py` çš„è¨ºæ–·æ–¹æ³•**ï¼š
```python
def diagnose_async_updater_status(self):
    """è¨ºæ–·ç•°æ­¥æ›´æ–°å™¨ç‹€æ…‹"""
    try:
        print("\nğŸ” ç•°æ­¥æ›´æ–°å™¨è¨ºæ–·:")
        
        if hasattr(self, 'multi_group_position_manager') and self.multi_group_position_manager:
            manager = self.multi_group_position_manager
            
            if hasattr(manager, 'async_updater') and manager.async_updater:
                updater = manager.async_updater
                
                # æª¢æŸ¥éšŠåˆ—ç‹€æ…‹
                if hasattr(updater, 'update_queue'):
                    queue_size = len(updater.update_queue) if updater.update_queue else 0
                    print(f"  ğŸ“Š æ›´æ–°éšŠåˆ—å¤§å°: {queue_size}")
                    
                    if queue_size > 10:
                        print(f"  âš ï¸ éšŠåˆ—ç©å£“åš´é‡: {queue_size}å€‹ä»»å‹™")
                
                # æª¢æŸ¥é‹è¡Œç‹€æ…‹
                if hasattr(updater, 'is_running'):
                    print(f"  ğŸ“Š é‹è¡Œç‹€æ…‹: {updater.is_running}")
                
                # æª¢æŸ¥æœ€å¾Œæ›´æ–°æ™‚é–“
                if hasattr(updater, 'last_update_time'):
                    import time
                    if updater.last_update_time:
                        elapsed = time.time() - updater.last_update_time
                        print(f"  ğŸ“Š æœ€å¾Œæ›´æ–°: {elapsed:.1f}ç§’å‰")
                        if elapsed > 30:
                            print(f"  âš ï¸ æ›´æ–°å»¶é²éä¹…: {elapsed:.1f}ç§’")
                
                # æª¢æŸ¥çµ±è¨ˆä¿¡æ¯
                if hasattr(updater, 'get_stats'):
                    stats = updater.get_stats()
                    print(f"  ğŸ“Š æ›´æ–°çµ±è¨ˆ: {stats}")
            
            else:
                print(f"  âŒ ç•°æ­¥æ›´æ–°å™¨ä¸å­˜åœ¨")
        else:
            print(f"  âŒ multi_group_position_manager ä¸å­˜åœ¨")
            
    except Exception as e:
        print(f"  âŒ ç•°æ­¥æ›´æ–°å™¨è¨ºæ–·å¤±æ•—: {e}")
```

#### **2. ç·©å­˜ç‹€æ…‹æª¢æŸ¥**
```python
def diagnose_optimized_risk_manager_cache(self):
    """è¨ºæ–·OptimizedRiskManagerç·©å­˜ç‹€æ…‹"""
    try:
        print("\nğŸ” OptimizedRiskManagerç·©å­˜è¨ºæ–·:")
        
        if hasattr(self, 'optimized_risk_manager') and self.optimized_risk_manager:
            manager = self.optimized_risk_manager
            
            # æª¢æŸ¥å•é¡Œéƒ¨ä½
            problem_positions = [133, 134, 135]
            
            for position_id in problem_positions:
                position_id_str = str(position_id)
                
                # æª¢æŸ¥position_cache
                in_position_cache = position_id_str in manager.position_cache
                print(f"  ğŸ“Š éƒ¨ä½{position_id}:")
                print(f"    - position_cache: {in_position_cache}")
                
                if in_position_cache:
                    pos_data = manager.position_cache[position_id_str]
                    print(f"    - ç·©å­˜æ–¹å‘: {pos_data.get('direction', 'N/A')}")
                    print(f"    - ç·©å­˜ç‹€æ…‹: {pos_data.get('status', 'N/A')}")
                
                # æª¢æŸ¥stop_loss_cache
                in_stop_loss_cache = position_id_str in manager.stop_loss_cache
                print(f"    - stop_loss_cache: {in_stop_loss_cache}")
                if in_stop_loss_cache:
                    stop_loss = manager.stop_loss_cache[position_id_str]
                    print(f"    - åœæåƒ¹æ ¼: {stop_loss}")
                
                # æª¢æŸ¥trailing_cache
                in_trailing_cache = position_id_str in manager.trailing_cache
                print(f"    - trailing_cache: {in_trailing_cache}")
                if in_trailing_cache:
                    trailing_data = manager.trailing_cache[position_id_str]
                    print(f"    - ç§»å‹•åœåˆ©ç‹€æ…‹: {trailing_data}")
            
            # æª¢æŸ¥ç¸½é«”ç·©å­˜å¤§å°
            print(f"  ğŸ“Š ç¸½é«”ç·©å­˜ç‹€æ…‹:")
            print(f"    - position_cache: {len(manager.position_cache)}å€‹éƒ¨ä½")
            print(f"    - stop_loss_cache: {len(manager.stop_loss_cache)}å€‹åœæ")
            print(f"    - trailing_cache: {len(manager.trailing_cache)}å€‹ç§»å‹•åœåˆ©")
            
        else:
            print(f"  âŒ optimized_risk_manager ä¸å­˜åœ¨")
            
    except Exception as e:
        print(f"  âŒ ç·©å­˜è¨ºæ–·å¤±æ•—: {e}")
```

### **ğŸ¯ å£ç´šåˆ¥æ›´æ–°æ©Ÿåˆ¶è¨ºæ–·**

#### **1. SimplifiedOrderTrackerç‹€æ…‹æª¢æŸ¥**
```python
def diagnose_simplified_tracker_status(self):
    """è¨ºæ–·SimplifiedOrderTrackerç‹€æ…‹"""
    try:
        print("\nğŸ” SimplifiedOrderTrackerè¨ºæ–·:")
        
        # æª¢æŸ¥stop_loss_executor
        if hasattr(self, 'stop_loss_executor') and self.stop_loss_executor:
            executor = self.stop_loss_executor
            
            # æª¢æŸ¥simplified_tracker
            if hasattr(executor, 'simplified_tracker') and executor.simplified_tracker:
                tracker = executor.simplified_tracker
                print(f"  âœ… simplified_tracker å­˜åœ¨")
                
                # æª¢æŸ¥exit_groups
                if hasattr(tracker, 'exit_groups'):
                    exit_groups_count = len(tracker.exit_groups)
                    print(f"  ğŸ“Š exit_groups: {exit_groups_count}å€‹")
                    
                    # æª¢æŸ¥å•é¡Œéƒ¨ä½çš„exit_groups
                    problem_positions = [133, 134, 135]
                    for position_id in problem_positions:
                        if position_id in tracker.exit_groups:
                            exit_group = tracker.exit_groups[position_id]
                            print(f"    - éƒ¨ä½{position_id}: å­˜åœ¨exit_group")
                            print(f"      æ–¹å‘: {exit_group.direction}")
                            print(f"      ç¸½å£æ•¸: {exit_group.total_lots}")
                            print(f"      è¿½åƒ¹æ¬¡æ•¸: {exit_group.individual_retry_counts}")
                        else:
                            print(f"    - éƒ¨ä½{position_id}: ç„¡exit_group")
                
                # æª¢æŸ¥global_exit_manager
                if hasattr(tracker, 'global_exit_manager'):
                    manager = tracker.global_exit_manager
                    print(f"  ğŸ“Š global_exit_manager:")
                    print(f"    - é–å®šè¶…æ™‚: {manager.exit_timeout}ç§’")
                    print(f"    - ç•¶å‰é–å®š: {len(manager.exit_locks)}å€‹")
                    
                    # é¡¯ç¤ºç•¶å‰é–å®š
                    import time
                    for key, info in manager.exit_locks.items():
                        elapsed = time.time() - info['timestamp']
                        print(f"      {key}: {elapsed:.1f}ç§’å‰ ({info['trigger_source']})")
            
            else:
                print(f"  âŒ simplified_tracker ä¸å­˜åœ¨")
        else:
            print(f"  âŒ stop_loss_executor ä¸å­˜åœ¨")
            
    except Exception as e:
        print(f"  âŒ SimplifiedTrackerè¨ºæ–·å¤±æ•—: {e}")
```

#### **2. è³‡æ–™åº«æŸ¥è©¢æ€§èƒ½ç›£æ§**
```python
def diagnose_database_query_performance(self):
    """è¨ºæ–·è³‡æ–™åº«æŸ¥è©¢æ€§èƒ½"""
    try:
        print("\nğŸ” è³‡æ–™åº«æŸ¥è©¢æ€§èƒ½è¨ºæ–·:")

        if hasattr(self, 'stop_loss_executor') and self.stop_loss_executor:
            executor = self.stop_loss_executor

            # æ¸¬è©¦æŸ¥è©¢æ€§èƒ½
            problem_positions = [133, 134, 135]

            for position_id in problem_positions:
                import time
                start_time = time.time()

                # èª¿ç”¨å¯¦éš›çš„æŸ¥è©¢æ–¹æ³•
                if hasattr(executor, '_get_position_info'):
                    result = executor._get_position_info(position_id)
                    elapsed = (time.time() - start_time) * 1000

                    print(f"  ğŸ“Š éƒ¨ä½{position_id}æŸ¥è©¢:")
                    print(f"    - è€—æ™‚: {elapsed:.1f}ms")
                    print(f"    - çµæœ: {'æˆåŠŸ' if result else 'å¤±æ•—'}")

                    if elapsed > 100:
                        print(f"    âš ï¸ æŸ¥è©¢å»¶é²éé«˜: {elapsed:.1f}ms")

                    if not result:
                        print(f"    âŒ æŸ¥è©¢å¤±æ•—ï¼Œéœ€è¦è©³ç´°è¨ºæ–·")

    except Exception as e:
        print(f"  âŒ è³‡æ–™åº«æŸ¥è©¢è¨ºæ–·å¤±æ•—: {e}")
```

#### **3. å£ç´šåˆ¥é–å®šæ©Ÿåˆ¶æª¢æŸ¥**
```python
def diagnose_lot_level_locking(self):
    """è¨ºæ–·å£ç´šåˆ¥é–å®šæ©Ÿåˆ¶"""
    try:
        print("\nğŸ” å£ç´šåˆ¥é–å®šæ©Ÿåˆ¶è¨ºæ–·:")

        # æª¢æŸ¥GlobalExitManager
        if hasattr(self, 'stop_loss_executor') and self.stop_loss_executor:
            if hasattr(self.stop_loss_executor, 'simplified_tracker'):
                tracker = self.stop_loss_executor.simplified_tracker
                if tracker and hasattr(tracker, 'global_exit_manager'):
                    manager = tracker.global_exit_manager

                    print(f"  ğŸ“Š å…¨å±€å¹³å€‰ç®¡ç†å™¨:")
                    print(f"    - é–å®šè¶…æ™‚: {manager.exit_timeout}ç§’")
                    print(f"    - ç•¶å‰é–å®šæ•¸é‡: {len(manager.exit_locks)}")

                    # æª¢æŸ¥å•é¡Œéƒ¨ä½çš„é–å®šç‹€æ…‹
                    problem_positions = [133, 134, 135]
                    for position_id in problem_positions:
                        position_key = str(position_id)

                        # æª¢æŸ¥éƒ¨ä½ç´šåˆ¥é–å®š
                        if position_key in manager.exit_locks:
                            lock_info = manager.exit_locks[position_key]
                            import time
                            elapsed = time.time() - lock_info['timestamp']
                            print(f"    - éƒ¨ä½{position_id}: å·²é–å®š {elapsed:.1f}ç§’")
                            print(f"      è§¸ç™¼æº: {lock_info['trigger_source']}")
                            print(f"      é¡å‹: {lock_info['exit_type']}")
                        else:
                            print(f"    - éƒ¨ä½{position_id}: æœªé–å®š")

                        # æª¢æŸ¥å£ç´šåˆ¥é–å®š
                        for lot_index in range(1, 4):  # å‡è¨­æœ€å¤š3å£
                            lot_key = f"{position_id}_lot_{lot_index}"
                            if lot_key in manager.exit_locks:
                                lock_info = manager.exit_locks[lot_key]
                                elapsed = time.time() - lock_info['timestamp']
                                print(f"      ç¬¬{lot_index}å£: å·²é–å®š {elapsed:.1f}ç§’")
                            else:
                                print(f"      ç¬¬{lot_index}å£: æœªé–å®š")

    except Exception as e:
        print(f"  âŒ å£ç´šåˆ¥é–å®šè¨ºæ–·å¤±æ•—: {e}")
```

### **ğŸ”„ å¯¦æ™‚è¨ºæ–·è§¸ç™¼æ©Ÿåˆ¶**

#### **1. åœ¨OnNewDataä¸­æ·»åŠ è¨ºæ–·è§¸ç™¼**
```python
# åœ¨ OnNotifyTicksLONG æ–¹æ³•ä¸­æ·»åŠ  (å ±åƒ¹è™•ç†å»¶é²è­¦å‘Šå¾Œ)

# ğŸ“Š æ€§èƒ½ç›£æ§ï¼šè¨ˆç®—å ±åƒ¹è™•ç†ç¸½è€—æ™‚
quote_elapsed = (time.time() - quote_start_time) * 1000

# ğŸš¨ å»¶é²è­¦å‘Šï¼šå¦‚æœå ±åƒ¹è™•ç†è¶…é100msï¼Œè¼¸å‡ºè­¦å‘Š
if quote_elapsed > 100:
    print(f"[PERFORMANCE] âš ï¸ å ±åƒ¹è™•ç†å»¶é²: {quote_elapsed:.1f}ms")

    # ğŸ” è§¸ç™¼è¨ºæ–·ï¼ˆåªåœ¨å»¶é²åš´é‡æ™‚ï¼‰
    if quote_elapsed > 1000:  # è¶…é1ç§’æ‰è¨ºæ–·
        print(f"[DIAGNOSTIC] ğŸš¨ è§¸ç™¼ç·Šæ€¥è¨ºæ–·")
        self.run_comprehensive_diagnosis()

# ğŸ” å®šæœŸè¨ºæ–·ï¼ˆæ¯1000æ¬¡å ±åƒ¹ï¼‰
if hasattr(self, 'diagnostic_counter'):
    self.diagnostic_counter += 1
else:
    self.diagnostic_counter = 1

if self.diagnostic_counter % 1000 == 0:
    print(f"[DIAGNOSTIC] ğŸ“Š å®šæœŸè¨ºæ–· (ç¬¬{self.diagnostic_counter}æ¬¡å ±åƒ¹)")
    self.run_comprehensive_diagnosis()
```

#### **2. ç¶œåˆè¨ºæ–·æ–¹æ³•**
```python
def run_comprehensive_diagnosis(self):
    """é‹è¡Œç¶œåˆè¨ºæ–· - åœ¨å ±åƒ¹è™•ç†ä¸­èª¿ç”¨"""
    print("\n" + "="*60)
    print("ğŸš¨ å¹³å€‰å•é¡Œç¶œåˆè¨ºæ–·")
    print("="*60)

    # é‹è¡Œæ‰€æœ‰è¨ºæ–·
    self.diagnose_async_updater_status()
    self.diagnose_optimized_risk_manager_cache()
    self.diagnose_simplified_tracker_status()
    self.diagnose_database_query_performance()
    self.diagnose_lot_level_locking()

    print("\n" + "="*60)
    print("ğŸ” è¨ºæ–·å®Œæˆ")
    print("="*60)
```

---

## ğŸ¯ **é æœŸä¿®å¾©ç­–ç•¥**

### **çŸ­æœŸä¿®å¾©ï¼ˆç·Šæ€¥ï¼‰**

#### **1. å¢å¼·æŸ¥è©¢å®¹éŒ¯æ€§**
```python
def _get_position_info_with_retry(self, position_id: int, max_retries: int = 3) -> Optional[Dict]:
    """å¢å¼·ç‰ˆéƒ¨ä½æŸ¥è©¢ - å¸¶é‡è©¦å’Œè¶…æ™‚è™•ç†"""
    for attempt in range(max_retries):
        try:
            with sqlite3.connect(self.db_path, timeout=2.0) as conn:
                cursor = conn.cursor()

                # åŸæœ‰æŸ¥è©¢é‚è¼¯...
                result = self._execute_join_query(cursor, position_id)

                if result:
                    return result
                elif attempt < max_retries - 1:
                    print(f"[STOP_EXECUTOR] ğŸ”„ éƒ¨ä½{position_id}æŸ¥è©¢é‡è©¦ {attempt + 1}/{max_retries}")
                    time.sleep(0.1)  # çŸ­æš«ç­‰å¾…

        except sqlite3.OperationalError as e:
            if "database is locked" in str(e) and attempt < max_retries - 1:
                print(f"[STOP_EXECUTOR] ğŸ”’ è³‡æ–™åº«é–å®šï¼Œé‡è©¦ {attempt + 1}/{max_retries}")
                time.sleep(0.2)
            else:
                raise

    return None
```

#### **2. ç·©å­˜æ¸…ç†æ©Ÿåˆ¶**
```python
def clear_failed_position_cache(self, position_id: str):
    """æ¸…ç†å¤±æ•—éƒ¨ä½çš„ç·©å­˜"""
    try:
        # æ¸…ç†OptimizedRiskManagerç·©å­˜
        if hasattr(self, 'optimized_risk_manager'):
            manager = self.optimized_risk_manager
            manager.position_cache.pop(position_id, None)
            manager.stop_loss_cache.pop(position_id, None)
            manager.trailing_cache.pop(position_id, None)
            print(f"[CACHE_CLEAR] ğŸ§¹ æ¸…ç†éƒ¨ä½{position_id}ç·©å­˜")

        # æ¸…ç†å…¨å±€é–å®š
        if hasattr(self, 'global_exit_manager'):
            self.global_exit_manager.clear_exit(position_id)
            print(f"[LOCK_CLEAR] ğŸ”“ æ¸…ç†éƒ¨ä½{position_id}é–å®š")

    except Exception as e:
        print(f"[CACHE_CLEAR] âŒ æ¸…ç†å¤±æ•—: {e}")
```

### **ä¸­æœŸä¿®å¾©ï¼ˆæ ¹æœ¬ï¼‰**

#### **1. ç•°æ­¥æŸ¥è©¢æ©Ÿåˆ¶**
```python
async def _get_position_info_async(self, position_id: int) -> Optional[Dict]:
    """ç•°æ­¥éƒ¨ä½æŸ¥è©¢ - é¿å…é˜»å¡å ±åƒ¹ç·šç¨‹"""
    import asyncio
    import aiosqlite

    try:
        async with aiosqlite.connect(self.db_path) as conn:
            cursor = await conn.cursor()

            # ç•°æ­¥åŸ·è¡ŒæŸ¥è©¢
            await cursor.execute('''
                SELECT pr.*, sg.range_high, sg.range_low, sg.direction as group_direction
                FROM position_records pr
                JOIN strategy_groups sg ON pr.group_id = sg.group_id
                WHERE pr.id = ? AND pr.status = 'ACTIVE'
            ''', (position_id,))

            row = await cursor.fetchone()
            if row:
                columns = [description[0] for description in cursor.description]
                return dict(zip(columns, row))

            return None

    except Exception as e:
        print(f"[ASYNC_QUERY] âŒ ç•°æ­¥æŸ¥è©¢å¤±æ•—: {e}")
        return None
```

#### **2. å£ç´šåˆ¥æ©Ÿåˆ¶ç°¡åŒ–**
```python
def simplified_exit_registration(self, position_id: int, direction: str):
    """ç°¡åŒ–çš„å¹³å€‰è¨»å†Š - æ¸›å°‘ä½µç™¼è¡çª"""
    try:
        # åªåœ¨å¿…è¦æ™‚è¨»å†Šï¼Œé¿å…éåº¦è¤‡é›œåŒ–
        if self.simplified_tracker and not self.simplified_tracker.exit_groups.get(position_id):
            # ç°¡åŒ–è¨»å†Šé‚è¼¯ï¼Œæ¸›å°‘è³‡æ–™åº«æ“ä½œ
            exit_group = ExitGroup(
                position_id=position_id,
                total_lots=1,
                direction=direction,
                exit_direction="SELL" if direction == "LONG" else "BUY",
                target_price=0.0,  # å‹•æ…‹è¨ˆç®—
                product="TM0000"
            )

            self.simplified_tracker.exit_groups[position_id] = exit_group
            print(f"[EXIT_REG] âœ… ç°¡åŒ–è¨»å†Šéƒ¨ä½{position_id}")

    except Exception as e:
        print(f"[EXIT_REG] âŒ è¨»å†Šå¤±æ•—: {e}")
```

---

## ğŸ“Š **ç›£æ§æŒ‡æ¨™**

### **é—œéµæ€§èƒ½æŒ‡æ¨™ (KPI)**

#### **1. æŸ¥è©¢æ€§èƒ½æŒ‡æ¨™**
- éƒ¨ä½æŸ¥è©¢å¹³å‡è€—æ™‚ < 50ms
- æŸ¥è©¢æˆåŠŸç‡ > 99%
- è³‡æ–™åº«é–å®šæ¬¡æ•¸ < 1æ¬¡/å°æ™‚

#### **2. ç•°æ­¥æ›´æ–°æŒ‡æ¨™**
- ç•°æ­¥éšŠåˆ—å¤§å° < 10å€‹ä»»å‹™
- æ›´æ–°å»¶é² < 5ç§’
- æ›´æ–°æˆåŠŸç‡ > 99%

#### **3. å£ç´šåˆ¥æ©Ÿåˆ¶æŒ‡æ¨™**
- ExitGroupè¨»å†ŠæˆåŠŸç‡ > 99%
- å£ç´šåˆ¥é–å®šè¡çª < 1æ¬¡/å°æ™‚
- å¹³å€‰è¿½åƒ¹æˆåŠŸç‡ > 95%

### **å‘Šè­¦é–¾å€¼**

#### **ğŸš¨ ç·Šæ€¥å‘Šè­¦**
- å ±åƒ¹è™•ç†å»¶é² > 1000ms
- æŸ¥è©¢å¤±æ•—ç‡ > 5%
- ç•°æ­¥éšŠåˆ—ç©å£“ > 50å€‹ä»»å‹™

#### **âš ï¸ è­¦å‘Šå‘Šè­¦**
- å ±åƒ¹è™•ç†å»¶é² > 100ms
- æŸ¥è©¢è€—æ™‚ > 100ms
- ç•°æ­¥æ›´æ–°å»¶é² > 30ç§’

---

## ğŸ“‹ **å¯¦æ–½è¨ˆåŠƒ**

### **ç¬¬1éšæ®µï¼šç«‹å³è¨ºæ–· (ç•¶å¤©)**
1. âœ… åœ¨ `simple_integrated.py` ä¸­æ·»åŠ è¨ºæ–·æ–¹æ³•
2. âœ… åœ¨ `OnNewData` ä¸­æ·»åŠ è¨ºæ–·è§¸ç™¼
3. âœ… é‹è¡Œç³»çµ±ä¸¦æ”¶é›†è¨ºæ–·æ•¸æ“š
4. âœ… åˆ†æå…·é«”çš„å¤±æ•—æ™‚æ©Ÿå’ŒåŸå› 

### **ç¬¬2éšæ®µï¼šç·Šæ€¥ä¿®å¾© (1-2å¤©)**
1. ğŸ”§ å¯¦æ–½æŸ¥è©¢é‡è©¦æ©Ÿåˆ¶
2. ğŸ”§ æ·»åŠ ç·©å­˜æ¸…ç†æ©Ÿåˆ¶
3. ğŸ”§ å¢å¼·éŒ¯èª¤è™•ç†å’Œæ—¥èªŒ
4. ğŸ”§ èª¿æ•´å£ç´šåˆ¥æ©Ÿåˆ¶åƒæ•¸

### **ç¬¬3éšæ®µï¼šæ ¹æœ¬ä¿®å¾© (1é€±)**
1. ğŸš€ å¯¦æ–½ç•°æ­¥æŸ¥è©¢æ©Ÿåˆ¶
2. ğŸš€ å„ªåŒ–ä½µç™¼æ§åˆ¶ç­–ç•¥
3. ğŸš€ ç°¡åŒ–å£ç´šåˆ¥æ©Ÿåˆ¶è¤‡é›œåº¦
4. ğŸš€ å®Œå–„ç›£æ§å’Œå‘Šè­¦ç³»çµ±

### **ç¬¬4éšæ®µï¼šé•·æœŸå„ªåŒ– (1å€‹æœˆ)**
1. ğŸ“ˆ æ€§èƒ½ç›£æ§å’Œèª¿å„ª
2. ğŸ“ˆ ç³»çµ±ç©©å®šæ€§é©—è­‰
3. ğŸ“ˆ æ–‡æª”å’Œç¶­è­·æŒ‡å—
4. ğŸ“ˆ é é˜²æ€§ç¶­è­·æ©Ÿåˆ¶

---

## ğŸ‰ **ç¸½çµ**

### **è¨ºæ–·çµè«–**
1. âœ… **å•é¡Œå®šä½æº–ç¢º**ï¼šç•°æ­¥æ›´æ–°èˆ‡å£ç´šåˆ¥æ©Ÿåˆ¶çš„ä½µç™¼è¡çª
2. âœ… **æ’é™¤æ–¹æ³•æœ‰æ•ˆ**ï¼šç³»çµ±æ€§æ’é™¤äº†åŸºç¤è³‡æ–™å’Œä»£ç¢¼çµæ§‹å•é¡Œ
3. âœ… **è¨ºæ–·å·¥å…·å®Œæ•´**ï¼šæä¾›äº†å®Œæ•´çš„è¨ºæ–·å·¥å…·éˆå’Œæ–¹æ³•è«–
4. âœ… **ä¿®å¾©æ–¹å‘æ˜ç¢º**ï¼šçŸ­æœŸå®¹éŒ¯ + ä¸­æœŸç•°æ­¥ + é•·æœŸå„ªåŒ–

### **é—œéµæˆæœ**
- ğŸ” **ç²¾ç¢ºå®šä½**ï¼šç¢ºèªå•é¡Œåœ¨é‹è¡Œæ™‚ä½µç™¼è™•ç†ï¼ŒéåŸºç¤è³‡æ–™
- ğŸ› ï¸ **å·¥å…·å®Œå‚™**ï¼šæä¾›å®Œæ•´çš„è¨ºæ–·å·¥å…·å’Œå¯¦æ™‚ç›£æ§æ©Ÿåˆ¶
- ğŸ“‹ **è¨ˆåŠƒæ¸…æ™°**ï¼šåˆ†éšæ®µçš„ä¿®å¾©å’Œå„ªåŒ–è¨ˆåŠƒ
- ğŸ¯ **æŒ‡æ¨™æ˜ç¢º**ï¼šå¯é‡åŒ–çš„ç›£æ§æŒ‡æ¨™å’Œå‘Šè­¦é–¾å€¼

**é€™ä»½è¨ºæ–·å ±å‘Šç‚ºå¹³å€‰å•é¡Œçš„å¾¹åº•è§£æ±ºæä¾›äº†å®Œæ•´çš„æ–¹æ³•è«–å’Œå¯¦æ–½è·¯å¾‘ã€‚**
```
