# å¹³å€‰å•é¡Œè¨ºæ–·èˆ‡ä½µç™¼è™•ç†æŠ€è¡“æŒ‡å—

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡ä»¶è©³ç´°åˆ†æ simple_integrated.py ç­–ç•¥ä¸‹å–®æ©Ÿä¸­çš„å¹³å€‰å•é¡Œè¨ºæ–·æ–¹æ³•ï¼Œå°æ¯”é–‹ç™¼ç­†è¨˜èˆ‡å¯¦éš›ä»£ç¢¼ï¼Œæä¾›å®Œæ•´çš„ä½µç™¼è™•ç†å’Œç•°æ­¥æ›´æ–°æ©Ÿåˆ¶æŠ€è¡“æŒ‡å—ã€‚

## ğŸš¨ æ ¸å¿ƒå•é¡Œè­˜åˆ¥

### å•é¡Œ1: ç•°æ­¥æ›´æ–°èˆ‡åŒæ­¥æŸ¥è©¢æ™‚åºè¡çª

**å•é¡Œæè¿°**: ç­–ç•¥ä¸‹å–®æ©Ÿåœ¨å¹³å€‰æ™‚å‡ºç¾"æ‰¾ä¸åˆ°éƒ¨ä½è³‡è¨Š"éŒ¯èª¤ï¼Œå°è‡´å¹³å€‰å¤±æ•—ä¸¦æŒçºŒé‡è¤‡è§¸ç™¼ã€‚

**æ ¹æœ¬åŸå› **:
- å ±åƒ¹è™•ç†å»¶é²å¯é”4688msï¼Œé è¶…é æœŸ
- ç•°æ­¥æ›´æ–°å™¨èˆ‡åŒæ­¥æŸ¥è©¢å­˜åœ¨æ™‚åºè¡çª
- ä½µç™¼è¨ªå•å°è‡´è³‡æ–™åº«é–å®š

### å•é¡Œ2: å£ç´šåˆ¥è¿½åƒ¹æ©Ÿåˆ¶ä½µç™¼å½±éŸ¿

**ä½µç™¼è¡çªå ´æ™¯**:
```
æ™‚é–“ç·šé‡å»ºï¼š
T1: éƒ¨ä½133åœæè§¸ç™¼ â†’ OptimizedRiskManageræª¢æ¸¬
T2: èª¿ç”¨StopLossExecutor.execute_stop_loss()
T3: å˜—è©¦register_exit_group() â†’ å¯èƒ½é˜»å¡
T4: åŒæ™‚éƒ¨ä½134ã€135ä¹Ÿè§¸ç™¼ â†’ ä½µç™¼è¡çª
T5: _get_position_info()æŸ¥è©¢æ™‚è³‡æ–™åº«è¢«é–å®š
T6: æŸ¥è©¢è¶…æ™‚è¿”å›None â†’ "æ‰¾ä¸åˆ°éƒ¨ä½è³‡è¨Š"
```

## ğŸ” ç•°æ­¥æ›´æ–°å™¨æ¶æ§‹åˆ†æ

### AsyncDatabaseUpdater åˆå§‹åŒ–

**ä½ç½®**: `simple_integrated.py` ç¬¬3705-3716è¡Œ

<augment_code_snippet path="Capital_Official_Framework/simple_integrated.py" mode="EXCERPT">
````python
# ğŸš€ åˆå§‹åŒ–å…¨å±€ç•°æ­¥æ›´æ–°å™¨ï¼ˆè§£æ±ºå ±åƒ¹å»¶é²å•é¡Œï¼‰
try:
    from async_db_updater import AsyncDatabaseUpdater
    self.async_updater = AsyncDatabaseUpdater(self.multi_group_db_manager, console_enabled=True)
    # ğŸ”‡ é è¨­é—œé–‰å³°å€¼æ›´æ–°æ—¥èªŒï¼ˆé¿å…éå¤šè¼¸å‡ºï¼‰
    self.async_updater.set_log_options(enable_peak_logs=False, enable_task_logs=False)
    self.async_updater.start()
    print("[MULTI_GROUP] ğŸš€ å…¨å±€ç•°æ­¥æ›´æ–°å™¨å·²å•Ÿå‹•")
    print("[MULTI_GROUP] ğŸ”‡ å³°å€¼æ›´æ–°æ—¥èªŒå·²é è¨­é—œé–‰")
except Exception as e:
    print(f"[MULTI_GROUP] âš ï¸ ç•°æ­¥æ›´æ–°å™¨åˆå§‹åŒ–å¤±æ•—: {e}")
    self.async_updater = None
````
</augment_code_snippet>

### é¢¨éšªç®¡ç†å¼•æ“é€£æ¥

**ä½ç½®**: `simple_integrated.py` ç¬¬3721-3734è¡Œ

<augment_code_snippet path="Capital_Official_Framework/simple_integrated.py" mode="EXCERPT">
````python
# ğŸš€ é€£æ¥å…¨å±€ç•°æ­¥æ›´æ–°å™¨åˆ°é¢¨éšªç®¡ç†å¼•æ“
if hasattr(self, 'async_updater') and self.async_updater:
    # ğŸ”§ æª¢æŸ¥ç•°æ­¥æ›´æ–°å™¨å¥åº·ç‹€æ…‹
    if self.async_updater.running and self.async_updater.worker_thread and self.async_updater.worker_thread.is_alive():
        self.multi_group_risk_engine.set_async_updater(self.async_updater)
        print("[MULTI_GROUP] ğŸ”— é¢¨éšªç®¡ç†å¼•æ“å·²é€£æ¥å…¨å±€ç•°æ­¥æ›´æ–°å™¨")
    else:
        print("[MULTI_GROUP] âš ï¸ ç•°æ­¥æ›´æ–°å™¨æœªæ­£å¸¸é‹è¡Œï¼Œå˜—è©¦é‡å•Ÿ...")
        self.async_updater.start()  # é‡æ–°å•Ÿå‹•
        if self.async_updater.running:
            self.multi_group_risk_engine.set_async_updater(self.async_updater)
            print("[MULTI_GROUP] ğŸ”— é¢¨éšªç®¡ç†å¼•æ“å·²é€£æ¥é‡å•Ÿå¾Œçš„ç•°æ­¥æ›´æ–°å™¨")
        else:
            print("[MULTI_GROUP] âŒ ç•°æ­¥æ›´æ–°å™¨é‡å•Ÿå¤±æ•—")
````
</augment_code_snippet>

## ğŸ¯ OptimizedRiskManager ç·©å­˜æ©Ÿåˆ¶

### ç·©å­˜æ¶æ§‹è¨­è¨ˆ

**ä½ç½®**: `optimized_risk_manager.py` ç¬¬61-86è¡Œ

<augment_code_snippet path="Capital_Official_Framework/optimized_risk_manager.py" mode="EXCERPT">
````python
# ğŸ“Š å…§å­˜ç·©å­˜
self.position_cache = {}  # {position_id: position_data}
self.stop_loss_cache = {}  # {position_id: stop_loss_price}
self.activation_cache = {}  # {position_id: activation_price}
self.trailing_cache = {}  # {position_id: trailing_data}

# â° æ™‚é–“æ§åˆ¶
self.last_backup_update = 0
self.backup_interval = 60.0  # ğŸ”§ ä¿®å¾©ï¼šæ”¹ç‚º60ç§’å‚™ä»½æ›´æ–°ï¼Œæ¸›å°‘å»¶é²
self.last_cache_refresh = 0
self.sync_skip_count = 0  # ğŸ”§ æ–°å¢ï¼šè·³éè¨ˆæ•¸å™¨

# ğŸ“ˆ çµ±è¨ˆä¿¡æ¯
self.stats = {
    'cache_hits': 0,
    'cache_misses': 0,
    'backup_syncs': 0,
    'fallback_calls': 0,
    'processing_errors': 0
}

# ğŸ”’ ç·šç¨‹å®‰å…¨
self.cache_lock = threading.RLock()
````
</augment_code_snippet>

### åƒ¹æ ¼æ›´æ–°è™•ç†é‚è¼¯

**ä½ç½®**: `optimized_risk_manager.py` ç¬¬183-213è¡Œ

<augment_code_snippet path="Capital_Official_Framework/optimized_risk_manager.py" mode="EXCERPT">
````python
def update_price(self, current_price: float, timestamp: str = None) -> Dict:
    """
    å„ªåŒ–ç‰ˆåƒ¹æ ¼æ›´æ–°è™•ç†
    
    Args:
        current_price: ç•¶å‰åƒ¹æ ¼
        timestamp: æ™‚é–“æˆ³
        
    Returns:
        Dict: è™•ç†çµæœçµ±è¨ˆ
    """
    if timestamp is None:
        timestamp = datetime.now().strftime('%H:%M:%S')
    
    try:
        # ğŸ›¡ï¸ å®‰å…¨æª¢æŸ¥ï¼šå¦‚æœåœ¨å›é€€æ¨¡å¼ï¼Œä½¿ç”¨åŸå§‹æ–¹æ³•
        if self.fallback_mode:
            return self._fallback_update(current_price, timestamp)
        
        # â° å‚™ä»½åŒæ­¥æ©Ÿåˆ¶
        current_time = time.time()
        if current_time - self.last_backup_update >= self.backup_interval:
            self._sync_with_database()
            self.last_backup_update = current_time
            self.stats['backup_syncs'] += 1
        
        # ğŸš€ ä¸»è¦é‚è¼¯ï¼šç´”å…§å­˜æ¯”è¼ƒ
        results = self._process_cached_positions(current_price, timestamp)
        
        self.stats['cache_hits'] += 1
        return results
````
</augment_code_snippet>

## ğŸ”§ è¨ºæ–·å·¥å…·å¯¦ç¾

### ç•°æ­¥æ›´æ–°å™¨ç‹€æ…‹è¨ºæ–·

**å»ºè­°å¯¦ç¾ä½ç½®**: `simple_integrated.py` æ–°å¢æ–¹æ³•

```python
def diagnose_async_updater_status(self):
    """è¨ºæ–·ç•°æ­¥æ›´æ–°å™¨ç‹€æ…‹"""
    try:
        print("\nğŸ” ç•°æ­¥æ›´æ–°å™¨è¨ºæ–·:")
        
        if hasattr(self, 'multi_group_position_manager') and self.multi_group_position_manager:
            manager = self.multi_group_position_manager
            
            if hasattr(manager, 'async_updater') and manager.async_updater:
                updater = manager.async_updater
                
                # æª¢æŸ¥éšŠåˆ—ç‹€æ…‹
                if hasattr(updater, 'update_queue'):
                    queue_size = len(updater.update_queue) if updater.update_queue else 0
                    print(f"  ğŸ“Š æ›´æ–°éšŠåˆ—å¤§å°: {queue_size}")
                    
                    if queue_size > 10:
                        print(f"  âš ï¸ éšŠåˆ—ç©å£“åš´é‡: {queue_size}å€‹ä»»å‹™")
                
                # æª¢æŸ¥é‹è¡Œç‹€æ…‹
                if hasattr(updater, 'is_running'):
                    print(f"  ğŸ“Š é‹è¡Œç‹€æ…‹: {updater.is_running}")
                
                # æª¢æŸ¥æœ€å¾Œæ›´æ–°æ™‚é–“
                if hasattr(updater, 'last_update_time'):
                    import time
                    if updater.last_update_time:
                        elapsed = time.time() - updater.last_update_time
                        print(f"  ğŸ“Š æœ€å¾Œæ›´æ–°: {elapsed:.1f}ç§’å‰")
                        if elapsed > 30:
                            print(f"  âš ï¸ æ›´æ–°å»¶é²éä¹…: {elapsed:.1f}ç§’")
            
            else:
                print(f"  âŒ ç•°æ­¥æ›´æ–°å™¨ä¸å­˜åœ¨")
        else:
            print(f"  âŒ multi_group_position_manager ä¸å­˜åœ¨")
            
    except Exception as e:
        print(f"  âŒ ç•°æ­¥æ›´æ–°å™¨è¨ºæ–·å¤±æ•—: {e}")
```

### ç·©å­˜ç‹€æ…‹æª¢æŸ¥

```python
def diagnose_optimized_risk_manager_cache(self):
    """è¨ºæ–·OptimizedRiskManagerç·©å­˜ç‹€æ…‹"""
    try:
        print("\nğŸ” OptimizedRiskManagerç·©å­˜è¨ºæ–·:")
        
        if hasattr(self, 'optimized_risk_manager') and self.optimized_risk_manager:
            manager = self.optimized_risk_manager
            
            # æª¢æŸ¥å•é¡Œéƒ¨ä½
            problem_positions = [133, 134, 135]
            
            for position_id in problem_positions:
                position_id_str = str(position_id)
                
                # æª¢æŸ¥position_cache
                in_position_cache = position_id_str in manager.position_cache
                print(f"  ğŸ“Š éƒ¨ä½{position_id}:")
                print(f"    - position_cache: {in_position_cache}")
                
                if in_position_cache:
                    pos_data = manager.position_cache[position_id_str]
                    print(f"    - ç·©å­˜æ–¹å‘: {pos_data.get('direction', 'N/A')}")
                    print(f"    - ç·©å­˜ç‹€æ…‹: {pos_data.get('status', 'N/A')}")
                
                # æª¢æŸ¥stop_loss_cache
                in_stop_loss_cache = position_id_str in manager.stop_loss_cache
                print(f"    - stop_loss_cache: {in_stop_loss_cache}")
                if in_stop_loss_cache:
                    stop_loss = manager.stop_loss_cache[position_id_str]
                    print(f"    - åœæåƒ¹æ ¼: {stop_loss}")
            
            # æª¢æŸ¥ç¸½é«”ç·©å­˜å¤§å°
            print(f"  ğŸ“Š ç¸½é«”ç·©å­˜ç‹€æ…‹:")
            print(f"    - position_cache: {len(manager.position_cache)}å€‹éƒ¨ä½")
            print(f"    - stop_loss_cache: {len(manager.stop_loss_cache)}å€‹åœæ")
            print(f"    - trailing_cache: {len(manager.trailing_cache)}å€‹ç§»å‹•åœåˆ©")
            
        else:
            print(f"  âŒ optimized_risk_manager ä¸å­˜åœ¨")
            
    except Exception as e:
        print(f"  âŒ ç·©å­˜è¨ºæ–·å¤±æ•—: {e}")
```

## ğŸš€ ä¿®å¾©ç­–ç•¥å¯¦ç¾

### çŸ­æœŸä¿®å¾©: å¢å¼·æŸ¥è©¢å®¹éŒ¯æ€§

```python
def _get_position_info_with_retry(self, position_id: int, max_retries: int = 3) -> Optional[Dict]:
    """å¢å¼·ç‰ˆéƒ¨ä½æŸ¥è©¢ - å¸¶é‡è©¦å’Œè¶…æ™‚è™•ç†"""
    for attempt in range(max_retries):
        try:
            with sqlite3.connect(self.db_path, timeout=2.0) as conn:
                cursor = conn.cursor()

                # åŸæœ‰æŸ¥è©¢é‚è¼¯...
                result = self._execute_join_query(cursor, position_id)

                if result:
                    return result
                elif attempt < max_retries - 1:
                    print(f"[STOP_EXECUTOR] ğŸ”„ éƒ¨ä½{position_id}æŸ¥è©¢é‡è©¦ {attempt + 1}/{max_retries}")
                    time.sleep(0.1)  # çŸ­æš«ç­‰å¾…

        except sqlite3.OperationalError as e:
            if "database is locked" in str(e) and attempt < max_retries - 1:
                print(f"[STOP_EXECUTOR] ğŸ”’ è³‡æ–™åº«é–å®šï¼Œé‡è©¦ {attempt + 1}/{max_retries}")
                time.sleep(0.2)
            else:
                raise

    return None
```

### ä¸­æœŸä¿®å¾©: ç·©å­˜æ¸…ç†æ©Ÿåˆ¶

```python
def clear_failed_position_cache(self, position_id: str):
    """æ¸…ç†å¤±æ•—éƒ¨ä½çš„ç·©å­˜"""
    try:
        # æ¸…ç†OptimizedRiskManagerç·©å­˜
        if hasattr(self, 'optimized_risk_manager'):
            manager = self.optimized_risk_manager
            manager.position_cache.pop(position_id, None)
            manager.stop_loss_cache.pop(position_id, None)
            manager.trailing_cache.pop(position_id, None)
            print(f"[CACHE_CLEAR] ğŸ§¹ æ¸…ç†éƒ¨ä½{position_id}ç·©å­˜")

        # æ¸…ç†å…¨å±€é–å®š
        if hasattr(self, 'global_exit_manager'):
            self.global_exit_manager.clear_exit(position_id)
            print(f"[LOCK_CLEAR] ğŸ”“ æ¸…ç†éƒ¨ä½{position_id}é–å®š")

    except Exception as e:
        print(f"[CACHE_CLEAR] âŒ æ¸…ç†å¤±æ•—: {e}")
```

## ğŸ“Š ç›£æ§æŒ‡æ¨™èˆ‡å‘Šè­¦

### é—œéµæ€§èƒ½æŒ‡æ¨™ (KPI)

#### æŸ¥è©¢æ€§èƒ½æŒ‡æ¨™
- éƒ¨ä½æŸ¥è©¢å¹³å‡è€—æ™‚ < 50ms
- æŸ¥è©¢æˆåŠŸç‡ > 99%
- è³‡æ–™åº«é–å®šæ¬¡æ•¸ < 1æ¬¡/å°æ™‚

#### ç•°æ­¥æ›´æ–°æŒ‡æ¨™
- ç•°æ­¥éšŠåˆ—å¤§å° < 10å€‹ä»»å‹™
- æ›´æ–°å»¶é² < 5ç§’
- æ›´æ–°æˆåŠŸç‡ > 99%

#### å£ç´šåˆ¥æ©Ÿåˆ¶æŒ‡æ¨™
- ExitGroupè¨»å†ŠæˆåŠŸç‡ > 99%
- å£ç´šåˆ¥é–å®šè¡çª < 1æ¬¡/å°æ™‚
- å¹³å€‰è¿½åƒ¹æˆåŠŸç‡ > 95%

### å‘Šè­¦é–¾å€¼

#### ğŸš¨ ç·Šæ€¥å‘Šè­¦
- å ±åƒ¹è™•ç†å»¶é² > 1000ms
- æŸ¥è©¢å¤±æ•—ç‡ > 5%
- ç•°æ­¥éšŠåˆ—ç©å£“ > 50å€‹ä»»å‹™

#### âš ï¸ è­¦å‘Šå‘Šè­¦
- å ±åƒ¹è™•ç†å»¶é² > 100ms
- æŸ¥è©¢è€—æ™‚ > 100ms
- ç•°æ­¥æ›´æ–°å»¶é² > 30ç§’

## ğŸ› ï¸ ç¶­è­·æ“ä½œæŒ‡å—

### ç•°æ­¥æ›´æ–°å™¨å¥åº·æª¢æŸ¥

**ä½ç½®**: `multi_group_position_manager.py` ç¬¬1871-1891è¡Œ

<augment_code_snippet path="Capital_Official_Framework/multi_group_position_manager.py" mode="EXCERPT">
````python
def restart_async_updater_if_needed(self):
    """å¦‚æœéœ€è¦ï¼Œé‡æ–°å•Ÿå‹•ç•°æ­¥æ›´æ–°å™¨"""
    if not self.check_async_updater_health():
        self.logger.info("ğŸ”„ é‡æ–°å•Ÿå‹•ç•°æ­¥æ›´æ–°å™¨...")
        try:
            # åœæ­¢èˆŠçš„æ›´æ–°å™¨
            if hasattr(self, 'async_updater'):
                self.async_updater.stop()

            # å‰µå»ºæ–°çš„æ›´æ–°å™¨
            from async_db_updater import AsyncDatabaseUpdater
            self.async_updater = AsyncDatabaseUpdater(self.db_manager, console_enabled=True)
            self.async_updater.start()

            self.logger.info("âœ… ç•°æ­¥æ›´æ–°å™¨é‡æ–°å•Ÿå‹•æˆåŠŸ")
            return True
        except Exception as e:
            self.logger.error(f"âŒ ç•°æ­¥æ›´æ–°å™¨é‡æ–°å•Ÿå‹•å¤±æ•—: {e}")
            self.async_update_enabled = False  # ç¦ç”¨ç•°æ­¥æ›´æ–°
            return False
    return True
````
</augment_code_snippet>

### æ•…éšœæ’é™¤æµç¨‹

**å•é¡Œ**: å¹³å€‰æŸ¥è©¢å¤±æ•—
**æª¢æŸ¥æ­¥é©Ÿ**:
1. æª¢æŸ¥ç•°æ­¥æ›´æ–°å™¨é‹è¡Œç‹€æ…‹
2. é©—è­‰ç·©å­˜æ•¸æ“šä¸€è‡´æ€§
3. ç›£æ§è³‡æ–™åº«é–å®šæƒ…æ³
4. æª¢æŸ¥ä½µç™¼è¨ªå•æ¨¡å¼

**å•é¡Œ**: å ±åƒ¹è™•ç†å»¶é²
**æª¢æŸ¥æ­¥é©Ÿ**:
1. ç›£æ§ç•°æ­¥éšŠåˆ—å¤§å°
2. æª¢æŸ¥ç·©å­˜å‘½ä¸­ç‡
3. é©—è­‰å‚™ä»½åŒæ­¥é »ç‡
4. åˆ†æä½µç™¼è¡çªæ¨¡å¼

## ğŸ”„ å¯¦æ–½è¨ˆåŠƒ

### ç¬¬1éšæ®µ: ç«‹å³è¨ºæ–· (ç•¶å¤©)
1. âœ… åœ¨ `simple_integrated.py` ä¸­æ·»åŠ è¨ºæ–·æ–¹æ³•
2. âœ… åœ¨ `OnNewData` ä¸­æ·»åŠ è¨ºæ–·è§¸ç™¼
3. âœ… é‹è¡Œç³»çµ±ä¸¦æ”¶é›†è¨ºæ–·æ•¸æ“š
4. âœ… åˆ†æå…·é«”çš„å¤±æ•—æ™‚æ©Ÿå’ŒåŸå› 

### ç¬¬2éšæ®µ: ç·Šæ€¥ä¿®å¾© (1-2å¤©)
1. ğŸ”§ å¯¦æ–½æŸ¥è©¢é‡è©¦æ©Ÿåˆ¶
2. ğŸ”§ æ·»åŠ ç·©å­˜æ¸…ç†æ©Ÿåˆ¶
3. ğŸ”§ å¢å¼·éŒ¯èª¤è™•ç†å’Œæ—¥èªŒ
4. ğŸ”§ èª¿æ•´å£ç´šåˆ¥æ©Ÿåˆ¶åƒæ•¸

### ç¬¬3éšæ®µ: æ ¹æœ¬ä¿®å¾© (1é€±)
1. ğŸš€ å¯¦æ–½ç•°æ­¥æŸ¥è©¢æ©Ÿåˆ¶
2. ğŸš€ å„ªåŒ–ä½µç™¼æ§åˆ¶ç­–ç•¥
3. ğŸš€ ç°¡åŒ–å£ç´šåˆ¥æ©Ÿåˆ¶è¤‡é›œåº¦
4. ğŸš€ å®Œå–„ç›£æ§å’Œå‘Šè­¦ç³»çµ±

## ğŸ“ ç¶­è­·è¨˜éŒ„

### å·²è­˜åˆ¥çš„é—œéµå•é¡Œ
1. âœ… **ç•°æ­¥æ›´æ–°èˆ‡åŒæ­¥æŸ¥è©¢æ™‚åºè¡çª**: ç¢ºèªç‚ºä¸»è¦åŸå› 
2. âœ… **å£ç´šåˆ¥è¿½åƒ¹æ©Ÿåˆ¶ä½µç™¼å½±éŸ¿**: å¢åŠ ç³»çµ±è¤‡é›œåº¦
3. âœ… **å ±åƒ¹è™•ç†å»¶é²**: å¯é”4688msï¼Œé è¶…é æœŸ
4. âœ… **è³‡æ–™åº«é–å®šè¡çª**: ä½µç™¼è¨ªå•å°è‡´æŸ¥è©¢å¤±æ•—

### é æœŸä¿®å¾©æ•ˆæœ
- âœ… æŸ¥è©¢æˆåŠŸç‡: æå‡è‡³99%+
- âœ… å ±åƒ¹è™•ç†å»¶é²: é™ä½è‡³100msä»¥ä¸‹
- âœ… ä½µç™¼è¡çª: æ¸›å°‘è‡³1æ¬¡/å°æ™‚ä»¥ä¸‹
- âœ… ç³»çµ±ç©©å®šæ€§: é¡¯è‘—æå‡
